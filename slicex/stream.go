package slicex

import (
	"fmt"
	"runtime"
)

type Stream[T any] interface {
	// AllMatch returns whether all elements of this stream match the provided predicate.
	AllMatch(predicate func(value T) bool) bool

	//AnyMatch Returns whether any elements of this stream match the provided predicate.
	AnyMatch(predicate func(value T) bool) bool

	// AsSlice returns a slice containing the elements of this stream.
	AsSlice() []T

	// Count returns the count of elements in this stream.
	Count() int

	// Distinct	returns a stream consisting of the distinct elements (according to cmp function) of this stream.
	Distinct(cmp func(a, b T) bool) Stream[T]

	// Filter returns a stream consisting of the elements of this stream that match the given predicate.
	Filter(predicate func(value T) bool) Stream[T]

	// FindFirst returns the first element of this stream, or false if the stream is empty.
	FindFirst() (T, bool)

	// Range performs an action for each element of this stream.
	Range(func(index int, value T))
}

type stream[T any] struct {
	ch        chan T
	interrupt chan struct{}
	finished  chan struct{}
}

func (s *stream[T]) AllMatch(predicate func(value T) bool) bool {
	for value := range s.ch {
		if !predicate(value) {
			return false
		}
	}
	return true
}

func (s *stream[T]) AnyMatch(predicate func(value T) bool) bool {
	for value := range s.ch {
		if predicate(value) {
			return true
		}
	}
	return false
}

func (s *stream[T]) AsSlice() []T {
	var r []T
	for value := range s.ch {
		r = append(r, value)
	}
	return r
}

func (s *stream[T]) Count() int {
	<-s.finished
	return len(s.ch)
}

func (s *stream[T]) Distinct(cmp func(value, exists T) bool) Stream[T] {
	r := &stream[T]{
		ch:       make(chan T, cap(s.ch)),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		values := make([]T, 0, cap(s.ch))
	outer:
		for value := range s.ch {
		inner:
			for exists := range r.ch {
				if cmp(value, exists) {
					continue outer
				}
				continue inner
			}
			r.ch <- value
			values = append(values, value)
		}
	}()
	return r
}

func (s *stream[T]) Filter(predicate func(value T) bool) Stream[T] {
	r := &stream[T]{
		ch:       make(chan T, cap(s.ch)),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		for value := range s.ch {
			if predicate(value) {
				r.ch <- value
			}
		}
	}()
	return r
}

func (s *stream[T]) FindFirst() (T, bool) {
	value, ok := <-s.ch
	return value, ok
}

func (s *stream[T]) Range(f func(index int, value T)) {
	go func() {
		var index int
		for value := range s.ch {
			f(index, value)
			index++
		}
	}()
}

func AsStream[T any](values ...T) Stream[T] {
	r := &stream[T]{
		ch:       make(chan T, len(values)),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		for _, value := range values {
			r.ch <- value
		}
	}()
	return r
}

// GenerateStream returns an infinite sequential unordered stream where each element is generated by the provided supplier.
func GenerateStream[T any](supplier func() T) Stream[T] {
	r := &stream[T]{
		ch:       make(chan T, 1),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		for {
			select {
			case r.ch <- supplier():
				return
			default:
				runtime.Gosched()
			}
		}
	}()
	return r
}

// IterateStream returns an infinite sequential ordered Stream produced by iterative application of a function f to an
// initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
func IterateStream[T any](seed T, f func(T) T) Stream[T] {
	r := &stream[T]{
		ch:       make(chan T, 1),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		pre := seed
		for {
			value := f(pre)
			r.ch <- value
			pre = value
		}
	}()
	return r
}

// StreamFlatMap returns a stream consisting of the results of replacing each element of this stream with the contents
// of a mapped stream produced by applying the provided mapping function to each element.
func StreamFlatMap[T any, R any](src Stream[T], mapper func(T) R) Stream[R] {
	s, ok := src.(*stream[T])
	var length int
	if !ok {
		panic(fmt.Errorf("slicex: failed to convert %T to %T", src, new(stream[T])))
	}
	length = cap(s.ch)
	r := &stream[R]{
		ch:       make(chan R, length),
		finished: make(chan struct{}),
	}
	go func() {
		defer close(r.finished)
		defer close(r.ch)
		for value := range s.ch {
			r.ch <- mapper(value)
		}
	}()
	return r
}
